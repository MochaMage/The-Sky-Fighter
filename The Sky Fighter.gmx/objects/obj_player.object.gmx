<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_f22</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_parent_fighter</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Speed Constants
PLAYER_DEFAULT_SPEED = 6;
PLAYER_AFTERBURNER_SPEED = PLAYER_DEFAULT_SPEED + 3;

// Afterburner constants
PLAYER_AFTERBURNER_INCREMENT = 0.10;
PLAYER_AFTERBURNER_DECREMENT = 0.05

// Bullet Constants
PLAYER_BULLET_INTERVAL = room_speed / 10;
PLAYER_BULLET_SPEED = PLAYER_DEFAULT_SPEED * 3;
PLAYER_MAX_GUN_HEAT = 100;
PLAYER_GUN_HEAT_INCREMENT = 10;
PLAYER_GUN_COOLDOWN = 2.5;
VIEW_CONE_ANGLE = 5;

// Turning Constants
PLAYER_MAX_TURN_ANGLE = 2;
PLAYER_TURN_INCREMENT = 0.25;
PLAYER_TURN_DECREMENT = 0.50;
PLAYER_SPRITE_DEFAULT = 0;
PLAYER_SPRITE_STD_TURN = 1;
PLAYER_SPRITE_HARD_TURN = 2;
PLAYER_GUN_COOLDOWN_PERIOD = room_speed * 5;
PLAYER_GUN_MAX_HEAT = 100
PLAYER_GUN_HEAT_INCREMENT = PLAYER_GUN_MAX_HEAT / 20;

// Health constants
PLAYER_STARTING_HEALTH = 100;
HEALTH_BAR_WIDTH = 150;
HEALTH_BAR_HEIGHT = 20;

// Missile constants
SCAN_CONE_LENGTH = 600;
SCAN_CONE_ANGLE = 15;
SCAN_SIDE_LENGTH = SCAN_CONE_LENGTH / cos(degtorad(SCAN_CONE_ANGLE));
LOCK_ON_TIME = room_speed * 0.5;

// Border of field constants
TIME_TILL_DEATH = 5 * room_speed;

// Goal coordinates for when player leaves play field
goal_x = 0;
goal_y = 0;

// Missile scanning cone triangle coordinates
corner_1_x = 0;
corner_1_y = 0;
corner_2_x = 0;
corner_2_y = 0;

// Missile lock-on state and target
missile_locked_on = false;
missile_target = 0;
lock_on_timer = LOCK_ON_TIME;

// Bullet cooldown
forced_cooldown = false;
gun_heat = 0;
is_shooting = false;

// Dodge Maneuver
can_dodge = true;
is_dodging = false;

speed = PLAYER_DEFAULT_SPEED;
afterburner = false;
hp = PLAYER_STARTING_HEALTH;
player_state = state.normal;
to_string = "Player";
on_border = false;
target = noone;
predict_crosshair = ds_map_create();

player_slot = 1;
var cruise_sound = audio_play_sound(snd_player_cruising, 9, true);
audio_sound_gain(cruise_sound, 0.25, 0);

max_turn_angle = PLAYER_MAX_TURN_ANGLE;
max_afterburner_speed = PLAYER_AFTERBURNER_SPEED;
afterburner_increment = PLAYER_AFTERBURNER_INCREMENT;
afterburner_decrement = PLAYER_AFTERBURNER_DECREMENT;
turn_increment = PLAYER_TURN_INCREMENT;
turn_decrement = PLAYER_TURN_DECREMENT;
default_speed = PLAYER_DEFAULT_SPEED;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sound_stop(snd_player_cruising);
ds_map_destroy(predict_crosshair);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player didn't move away from the boundary
hp = 0; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_dodge = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check inputs
// Check directional inputs
if(!is_dodging)
{
    if(inputdog_down("left", player_slot))
    {
        turn_ratio = min(1, inputdog_analog("left", player_slot));
    }
    
    if(inputdog_down("right", player_slot))
    {
        turn_ratio = -1 * min(1, inputdog_analog("right", player_slot));
    }
}

// Check face buttons
if(inputdog_down("a", player_slot))
{
    if(can_shoot &amp;&amp; !forced_cooldown)
    {
        var bullet = instance_create(x, y, obj_player_bullet);
        with(bullet)
        {
            speed = other.PLAYER_BULLET_SPEED;
            direction = other.direction;
            image_angle = other.image_angle;
            player_slot = other.player_slot;
        }
        alarm[0] = PLAYER_BULLET_INTERVAL;
        can_shoot = false;
        is_shooting = true;
        gun_heat += PLAYER_GUN_HEAT_INCREMENT;
        
        if(gun_heat == PLAYER_MAX_GUN_HEAT)
        {
            is_shooting = false;
            forced_cooldown = true;
        }
    }
}

if(inputdog_down("x", player_slot))
{
    afterburner = true;
    
    if(speed &lt; PLAYER_AFTERBURNER_SPEED){
        speed += PLAYER_AFTERBURNER_INCREMENT;}
}

if(inputdog_down("b", player_slot))
{
    if(can_dodge)
    {
        can_dodge = false;
        // Start dodge animation
        image_speed = 1;
        is_dodging = true;
    }
}

if(inputdog_pressed("y", player_slot))
{
    // Acquire a target. Pick nearest enemy. 
    // If a target is already set, then unset 
    // the target
    if(target == noone)
    {
        target = instance_nearest(x, y, obj_enemy);
    }
    else
    {
        target = noone;
    }
}

// Check for input releases
if(inputdog_released("left", player_slot) || inputdog_released("right", player_slot)){
    turn_ratio = 0;}
if(inputdog_released("a", player_slot)){
    is_shooting = false;}
if(inputdog_released("x", player_slot)){
    afterburner = false;}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Make player return to field. To be deprecated by self-destruction.
if(player_state == state.normal)
{
    if(turn_ratio &gt; 0)
    {
        if(turn_angle &lt; turn_ratio * max_turn_angle){
            turn_angle += turn_increment;}
    }
    else if(turn_ratio &lt; 0)
    {
        if(turn_angle &gt; turn_ratio * max_turn_angle){
            turn_angle -= turn_increment;}
    }
    else if(turn_angle != 0){
        turn_angle -= (abs(turn_angle)/turn_angle) * turn_decrement;}
    
    direction += turn_angle;
}
else
{
    mp_potential_settings(60, 30, 3, true);
    var reached_goal = mp_potential_step(goal_x, goal_y, default_speed, false);
    if(reached_goal){
        player_state = state.normal;}
}

// Check if player is too close to the border
if(place_meeting(x, y, obj_boundary))
{
    on_border = true;
}
else if(on_border)
{
    on_border = false
}

// Set the timer to blow up if player continues being on border
if(on_border &amp;&amp; alarm[2] == -1)
{
    alarm[2] = TIME_TILL_DEATH;
}

// Gatling gun logic
if(gun_heat &gt; 0 &amp;&amp; !is_shooting)
{
    if(forced_cooldown)
    {
        gun_heat -=  0.25 * PLAYER_GUN_COOLDOWN;
        if(gun_heat == 0){
            forced_cooldown = false}
    }
    else
    {
        gun_heat -= PLAYER_GUN_COOLDOWN;
    }
}

// Missile launcher logic
// Get coordinates for missile scanning cone
corner_1_x = x + lengthdir_x(SCAN_SIDE_LENGTH, direction - SCAN_CONE_ANGLE);
corner_2_x = x + lengthdir_x(SCAN_SIDE_LENGTH, direction + SCAN_CONE_ANGLE);

corner_1_y = y + lengthdir_y(SCAN_SIDE_LENGTH, direction - SCAN_CONE_ANGLE);
corner_2_y = y + lengthdir_y(SCAN_SIDE_LENGTH, direction + SCAN_CONE_ANGLE);

// Bullet aim prediction logic
// Create a narrow triangle that is as long as the diagonal of the view rectangle
var triangle_length = sqrt(power(view_wview[0], 2) + power(view_hview[0], 2));

if(target != noone)
{
    var target_distance = distance_to_point(target.x, target.y);
    var steps_to_target = ceil(target_distance / PLAYER_BULLET_SPEED);
    var reticle_dist = target.spd * steps_to_target;
    
    predict_crosshair[? "x"] = target.x + lengthdir_x(reticle_dist, target.direction);
    predict_crosshair[? "y"] = target.y + lengthdir_y(reticle_dist, target.direction);
}

/*if(missile_target)
{
   var in_range = point_in_triangle(missile_target.x, missile_target.y, 
        x, y, corner_1_x, corner_1_y, corner_2_x, corner_2_y);
   if(in_range &amp;&amp; lock_on_timer &gt; 0){
        lock_on_timer--;}
   else if(lock_on_timer == 0){
        missile_locked_on = true;}
   else
   {
        missile_target = 0;
        lock_on_timer = LOCK_ON_TIME;
   }
}
else
{
    for (var i = 0; i &lt; instance_number(obj_enemy); i++)
    {
       var fighter = instance_find(obj_enemy, i);
       var in_range = point_in_triangle(fighter.x, fighter.y, 
            x, y, corner_1_x, corner_1_y, corner_2_x, corner_2_y);
       if(in_range)
       {
            missile_target = fighter;
       }
    }
}*/

//view_angle = 90 - direction;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var collision_dmg = PLAYER_STARTING_HEALTH / 4;

other.hp -= collision_dmg;
hp -= collision_dmg;

if(other.hp &lt;= 0)
{
    global.scores[? string(player_slot)] += other.point_worth;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>is_dodging = false;
image_speed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>player_state = state.outside;
goal_x = xprevious;
goal_y = yprevious;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(on_border)
{
    // Display warning to player
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(view_wview[0]/2, view_hview[0]/2, "Return to the field of battle, pilot");
    draw_text(view_wview[0]/2, view_hview[0]/2 + 20, string(alarm[2]));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_alpha(0.5);
draw_line_width_colour(x, y, 
    lengthdir_x(view_wview[player_slot - 1], direction) + x, 
    lengthdir_y(view_wview[player_slot - 1], direction) + y,
    5, c_red, c_orange);
    
draw_triangle_colour(x, y, corner_1_x, corner_1_y, corner_2_x, corner_2_y, 
    c_red, c_green, c_green, false);
   
if(target != noone)
{ 
    if(!instance_exists(target))
    {
        target = noone;
    }
    else
    {
        draw_sprite(spr_player_missile_reticle, 0, 
            predict_crosshair[? "x"], predict_crosshair[? "y"]);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="9" enumb="67">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(missile_locked_on)
{
    var missile = instance_create(x, y, obj_player_missile);
    missile.target = missile_target;
    missile.launcher = id;
    missile.spd = speed;
    missile.direction = direction;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
