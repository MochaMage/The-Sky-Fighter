<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init
inputs = ds_list_create();
defaultKeys = ds_map_create();
defaultGamepadInputs = ds_map_create();
playerSlot = instance_number(InputManager);
global.editPlayerSlot = playerSlot; //for the remapping room
show_debug_message("created InputManager for Player "+string(playerSlot));

event_user(0); //add inputs

customKeys = ds_map_create();
customGamepadInputs = ds_map_create();
inputdog_load_default_keyboard_mapping();
inputdog_load_default_gamepad_mapping();

directInput = false;

inputdog_load_custom_controls();

gamepadSlot = -1;
event_perform(ev_alarm,0); //check for gamepads

inputsDown = ds_map_create();
var i;
for(i=0; i&lt;ds_list_size(inputs); i++)
{
    var INPUT = ds_list_find_value(inputs,i);
    ds_map_add(inputsDown,INPUT,0);
}

inputsDownLastFrame = ds_map_create();
ds_map_copy(inputsDownLastFrame,inputsDown);

rumbleEnabled = true;
rumble = 0;

analogDeadzone = 0.25; //when the analog value is big enough to be player input
analogDownDeadzone = 0.5; //when the analog val is enough to be a press

event_perform(ev_alarm,0); // find gamepads

if(object_index == InputManager)
    show_error("InputManager is a parent object that should not be instantiated. Try making InputForPlayer1 instead!",true);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///replays
replayFrame = 0;
replayFilename = "player_"+string(playerSlot)+"_replay.txt";

replayLog = ds_map_create();
lastInputsDown = "";
lastFrameRecorded = -1;

replayMode = "idle";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up
ds_list_destroy(inputs);

ds_map_destroy(defaultKeys);
ds_map_destroy(defaultGamepadInputs);

ds_map_destroy(customKeys);
ds_map_destroy(customGamepadInputs);

ds_map_destroy(inputsDown);
ds_map_destroy(inputsDownLastFrame);

ds_map_destroy(replayLog);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///search for gamepads
if(directInput)
    inputdog_search_for_joysticks();
else
    inputdog_search_for_gamepads();
alarm[0] = 120;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///update inputs
ds_map_copy(inputsDownLastFrame, inputsDown);

for(i=0; i&lt;ds_list_size(inputs); i++)
{
    var INPUT = ds_list_find_value(inputs,i);
    
    // keyboard input
    ds_map_replace(inputsDown, INPUT, inputdog_keyboard_check_direct(ds_map_find_value(customKeys, INPUT)));
    
    // gamepad input
    if(gamepadSlot != -1)
    {   
        // i like to allow the keyboard to still work even when a gamepad is plugged in
        var MAX = max(inputdog_down(INPUT,playerSlot), inputdog_check_gamepad_input(gamepadSlot, ds_map_find_value(customGamepadInputs,INPUT),directInput));
        ds_map_replace(inputsDown, INPUT, MAX);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///replays
switch(replayMode)
{
    case "record":
    var INPUTS_DOWN = inputdog_replay_get_input_string();
    if(INPUTS_DOWN != lastInputsDown)
    {
        ds_map_add(replayLog, replayFrame, INPUTS_DOWN);
        lastInputsDown = INPUTS_DOWN;
        show_debug_message("player "+string(playerSlot)+" saved frame "+string(replayFrame)+": "+INPUTS_DOWN);
    }
    break;
    
    case "play":
    //this is where you can allow actual inputs to interrupt the replay
    for(var i=0; i&lt;ds_list_size(inputs); i++)
    if(replayMode == "play")
    {
        var INPUT = ds_list_find_value(inputs,i);
        if(inputdog_down(INPUT,playerSlot))
        {
            with(InputManager)
                replayMode = "idle";
            show_debug_message("player "+string(playerSlot)+" exited replay playback");
        }
    }
    
    /*
        overwrite the live inputs 
    
        (last frame inputs are written as normal
              in the inputmanager begin step event)
    */  
    
    // get the current inputs from the log
    var INPUTS_DOWN = lastInputsDown;
    var CURRENT_INPUTS = ds_map_find_value(replayLog, replayFrame);
    if(not is_undefined(CURRENT_INPUTS))
    {
        show_debug_message("player "+string(playerSlot)+" found frame "+string(replayFrame)+": "+CURRENT_INPUTS);
        INPUTS_DOWN = CURRENT_INPUTS;
        lastInputsDown = INPUTS_DOWN;
    }
    
    //explode the string
    var STR = ds_list_create();
    var START = 0;
    
    var ITER = 0;
    while(START &lt;= string_length(INPUTS_DOWN) and ITER&lt;ds_list_size(inputs)+2)
    {
        ITER++;
        //show_debug_message("t");
        for(var i=START; i&lt;=string_length(INPUTS_DOWN); i++)
            if(string_char_at(INPUTS_DOWN, i) == "_")
            {
                ds_list_add(STR, string_copy(INPUTS_DOWN,START, i-START));
                START = i+1;
                break;
            }
    }
    
    // overwrite the live inputs
    for(var i=0; i&lt;ds_list_size(STR); i++)
    {
        var INPUT = ds_list_find_value(inputs,i);
        var BOOL = real(ds_list_find_value(STR,i));
        ds_map_replace(inputsDown,INPUT, BOOL);
    }
    
    //clean up ds
    ds_list_destroy(STR);
    
    // check for the end of the data
    if(replayFrame &gt;= lastFrameRecorded)
    {
        replayMode = "idle";
    }
    break;
}
replayFrame++;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///apply and fade rumble
if(gamepadSlot != -1)
    if(rumbleEnabled)
        gamepad_set_vibration(gamepadSlot, rumble, rumble);
    else
        gamepad_set_vibration(gamepadSlot, 0, 0);
    
var V = 0.01;
rumble = max(rumble-V,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>add custom inputs in child objects</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>4,4</point>
    <point>4,4</point>
  </PhysicsShapePoints>
</object>
